# -*- coding: utf-8 -*-
"""simulacion animales.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zIx1Pp4ZA_MK8EG7z5U3UIUmPCpY_45d

2 tipos de animales
- presa: conejo
- cazador: lobo

relaciones animales
- conejo + conejo = ↑ conejo
- conejo + lobo = ↓ conejo
- lobo + lobo = ↑ lobo

espacio donde esos animales se relacionan
- matriz de nxn
- ↓ elemento recibe una animal
- '+' de proximidad
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import animation as animation

CONEJO = 0
LOBO = 1

ARRIBA = 0
ABAJO = 1
IZQUIERDA = 2
DERECHA = 3
QUIETO = 4

# Numero inicial de conejos y lobos
nconejos = 200
nlobos = 20

# Tamaño de la grilla
gridxsize = 30
gridysize = 30

# energia de un conejo/lobo recientemente creado
rabben = 20
wolfen = 20

# probabilidad de que un nuevo conoje/lobo sea creado en cada paso de la grilla
probabilidad_nacimiento_conejo = 0.01
probabilidad_nacimiento_lobo = 0.01

# numero de pasos de la simulacion
steps = 200

class Animal(object):
    """
    Registra la posición del animal, la energía, la especie (conejo/lobo) y el estado (vivo/muerto).
    """

    def __init__(self, x0, y0, init_energy, species):
        self.x = x0
        self.y = y0
        self.energy = init_energy
        self.species = species
        self.isDead = False

    def interact(self, other):
        """
        Interactúa con otro animal:
            - Si son de la misma especie, ignora al otro.
            - El lobo se come al conejo.
        """
        if self.species == CONEJO and other.species == LOBO:
            self.die()
        elif self.species == LOBO and other.species == CONEJO:
            other.die()

    def die(self):
        "R.I.P"
        self.isDead = True

    def move(self, direction):
        """Mueve un paso en la cuadrícula. Cada paso consume 1 energía; si no queda energía, muere.
        Si golpea los límites de la cuadrícula, "retrocede", da un paso en la dirección opuesta.

        Argumentos:
            direction {int} -- dirección de movimiento: ARRIBA: 0, ABAJO: 1, IZQUIERDA: 2, DERECHA: 3, QUIETO: 4
        """
        self.energy -= 1

        if direction == IZQUIERDA:
            self.x += 1 if self.x > 0 else -1   #"bounce back"
        if direction == DERECHA:
            self.x -= 1 if self.x < gridxsize-1 else -1
        if direction == ARRIBA:
            self.y += 1 if self.y < gridysize-1 else -1
        if direction == ABAJO:
            self.y -= 1 if self.y > 0 else -1
        if direction == QUIETO:
            pass
        if self.energy <= 0:
            self.die()          #R.I.P.


animals = []        # esto contendrá todos los animales de la GRILLA

# todos los pares de coordenadas posibles
xcoords = np.arange(gridxsize)
ycoords = np.arange(gridysize)
coords = np.transpose([np.tile(xcoords, len(ycoords)), np.repeat(ycoords, len(xcoords))])

# poblar la cuadrícula al azar, coordenadas únicas para todos los animales
randcoords = np.random.permutation(coords)
rabbitcoords = randcoords[:nconejos]
wolfcoords = randcoords[nconejos:(nconejos + nlobos)]

for (x, y) in rabbitcoords:
    animals.append(Animal(x0=x, y0=y, init_energy=rabben, species=CONEJO))
for (x, y) in wolfcoords:
    animals.append(Animal(x0=x, y0=y, init_energy=wolfen, species=LOBO))

t_rabcoordsx = []   # rastrear las coordenadas de los animales en cada paso en estas matrices
t_rabcoordsy = []
t_wolfcoordsx = []
t_wolfcoordsy = []

rabbitnums, wolfnums = [nconejos], [nlobos]  #rastrear el número de conejos y lobos también

animfigs = []

for i in range(steps):
    # paso con cada animal en una dirección aleatoria
    directions = np.random.randint(0, 5, size=len(animals))
    for animal, direction in zip(animals, directions):
        animal.move(direction)
    # generar conejos recién nacidos...
    rabbit_is_born_here = np.random.rand(len(coords)) <= probabilidad_nacimiento_conejo
    newrabbits = coords[rabbit_is_born_here]
    for (x, y) in newrabbits:
        animals.append(Animal(x0=x, y0=y, init_energy=rabben, species = CONEJO))
    #... y los lobos
    wolf_is_born_here = np.random.rand(len(coords)) <= probabilidad_nacimiento_lobo
    newwolves = coords[wolf_is_born_here]
    for (x, y) in newwolves:
        animals.append(Animal(x0=x, y0=y, init_energy=wolfen, species = LOBO))
    # interactuar si dos animales están en las mismas coordenadas
    for j, animal1 in enumerate(animals):
        for animal2 in animals[j:]:
            if (animal1.x == animal2.x and
                animal1.y == animal2.y):
                animal1.interact(animal2)
    # limpiar cadáveres
    dead_indexes = []
    for j, animal in enumerate(animals):
        if animal.isDead:
            dead_indexes.append(j)
    animals = list(np.delete(animals, dead_indexes))
    # contar los animales y registrarlos
    wolfnum, rabnum = 0,0
    for animal in animals:
        if animal.species == CONEJO:
            rabnum += 1
        elif animal.species == LOBO:
            wolfnum += 1
    rabbitnums.append(rabnum)
    wolfnums.append(wolfnum)
    # print(rabnum, wolfnum, len(dead_indexes))
    # obtener y registrar las coordenadas de los animales
    rabcsx = []
    rabcsy = []
    wolfcsx = []
    wolfcsy = []
    for animal in animals:
        if animal.species == CONEJO:
            rabcsx.append(animal.x)
            rabcsy.append(animal.y)
            # ax.plot(, animal.y, 'bo')
        elif animal.species == LOBO:
            wolfcsx.append(animal.x)
            wolfcsy.append(animal.y)
            # ax.plot(animal.x, animal.y, 'ro')
    t_rabcoordsx.append(rabcsx)
    t_rabcoordsy.append(rabcsy)
    t_wolfcoordsx.append(wolfcsx)
    t_wolfcoordsy.append(wolfcsy)

#Visualizar el movimiento en una animación
fig, ax = plt.subplots()
fig.suptitle("Population vs time")
ax.set_xlim(0, gridxsize-1)
ax.set_ylim(0, gridysize-1)
ax.set_xticks(xcoords)
ax.set_yticks(ycoords)
plt.grid(True)

rabpc, = ax.plot(t_rabcoordsx[0], t_rabcoordsy[0], 'bo', label='rabbit')
wolfpc, = ax.plot(t_wolfcoordsx[0], t_wolfcoordsy[0], 'ro', label='wolf')
fig.legend()

txt = ax.text(0.1, 0.1,'', ha='center', va='center', alpha=0.8,
              transform=ax.transAxes, fontdict={'color':'black', 'backgroundcolor': 'white', 'size': 10})

#comenzar la animación:
def anim_init():
    rabpc.set_data(t_rabcoordsx[0], t_rabcoordsy[0])
    wolfpc.set_data(t_wolfcoordsx[0], t_wolfcoordsy[0])
    txt.set_text('rabbits: {}\nlobos:{}'.format(rabbitnums[0], wolfnums[0]))
    return rabpc, wolfpc, txt

#actualiza el gráfico
def animate(i):
    rabpc.set_data(t_rabcoordsx[i], t_rabcoordsy[i])
    wolfpc.set_data(t_wolfcoordsx[i], t_wolfcoordsy[i])
    txt.set_text('rabbits: {}\nlobos:{}'.format(rabbitnums[i], wolfnums[i]))
    return rabpc, wolfpc, txt

#construir y mostrar la animación
im_ani = animation.FuncAnimation(fig, animate, init_func=anim_init, frames=steps,
            interval=500, repeat=False, save_count=10, blit=True)
plt.show()

#trazar la población en el tiempo
plt.plot(rabbitnums, 'b-', label="rabbits",)
plt.plot(wolfnums, 'r-', label="wolves")
plt.xlabel('t')
plt.ylabel('population')
plt.suptitle("Population VS time")
plt.legend()
plt.show()

#trama rabbuts vs lobos
plt.suptitle("Rabbit vs wolf population")
plt.plot(rabbitnums, wolfnums)
plt.xlabel('rabbits')
plt.ylabel('wolves')
plt.show()